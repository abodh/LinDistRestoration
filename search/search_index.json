{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LinDistRestoration","text":"<p>Note</p> <p>The package is currently in a development stage and will have several code pushes in the next few weeks or so. Please use the current version carefully and stay updated with the latest version.</p> <p>LinDistRestoration is a package to solve a 3-phase unbalanced distribution system restoration problem using mixed-integer linear programming. This package is intented for users interested in solving linear optimal power flow problem. The linear power flow model is extracted from [1] and the base restoration models are based on [2], [3].</p> <p>Currently, LinDistRestoration supports parsing OpenDSS raw files and creates the data files required to solve the restoration model. User can either provide a valid OpenDSS file or create separate data files, see <code>examples/dataparser/parsed_data_iee123</code> for specific data files and their structure. The base restoration model solves the 3-phase unbalanced optimal power flow to maximize the load restoration based on faulted lines. LinDistRestoration does not support fault location module and it is assumed that user provides the fault data as an input. </p>"},{"location":"#getting-started","title":"Getting started","text":"<p>Please follow this installation process and examples to get started with LinDistRestoration.</p>"},{"location":"#references","title":"References","text":"<p> [1] L. Gan and S. H. Low, \"Convex relaxations and linear approximation for optimal power flow in multiphase radial networks,\" 2014 Power Systems Computation Conference, Warsaw, Poland, 2014, pp. 1-9.</p> <p> [2] A. Poudyal, S. Poudel and A. Dubey, \"Risk-Based Active Distribution System Planning for Resilience Against Extreme Weather Events,\" in IEEE Transactions on Sustainable Energy, vol. 14, no. 2, pp. 1178-1192, April 2023.</p> <p> [3] S. Poudel, A. Dubey and K. P. Schneider, \"A Generalized Framework for Service Restoration in a Resilient Power Distribution System,\" in IEEE Systems Journal, vol. 16, no. 1, pp. 252-263, March 2022.</p>"},{"location":"license/","title":"License","text":"<p>BSD 3-Clause License</p> <p>Copyright (c) 2024, Abodh Poudyal</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ul> <li> <p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p> </li> </ul> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"example/examples/","title":"Examples","text":""},{"location":"example/examples/#parse-opendss-data","title":"Parse OpenDSS data","text":"<p>Parse an OpenDSS model and save it in a local directory. An example script to parse the OpenDSS master file can be accessed from <code>examples/dataparser/data_parser.py</code></p> <pre><code>from ldrestoration import DSSManager  \n\n# 1. instantiate the DSSManager with the OpenDSS master file\ndss_object = DSSManager(r\"../test_cases/ieee123Bus/Run_IEEE123Bus.dss\")\n\n# 2. Parse the dss data to the ldrestoration data structure\ndss_object.parsedss()\n\n# 3. Save the parsed data in the desired output folder  \ndss_object.saveparseddss(folder_name=\"parsed_data_ieee123\")\n</code></pre>"},{"location":"example/examples/#instantiate-restoration-model","title":"Instantiate restoration model","text":"<p>Instantiate a restoration model by loading the data into the model.</p> <pre><code>from ldrestoration import RestorationBase\n\n# 1. identify the path of the parsed data files\nparsed_data_path = \"parsed_data_iee123/\"\n\n# 2. instantiate the restoration model\nrm = RestorationBase(parsed_data_path, base_kV_LL=4.16)\n</code></pre>"},{"location":"example/examples/#solve-the-restoration-model","title":"Solve the restoration model","text":"<p>solve the restoration model. To solve the model it needs to be instantiated first as shown above.</p> <pre><code># 3. identify objective function\nrm.objective_load_only()\n\n# 4. solve the restoration model with the solver of your choice \nrm_solved, results = rm.solve_model(solver='glpk')\n</code></pre>"},{"location":"example/examples/#extract-results-and-plot","title":"Extract results and plot","text":"<p>Once the model is solved, it can be plotted on the map to observe the restoration policy visually. To save the results in a csv file, you can pass <code>save_results=True</code> and <code>results_filename</code> as </p> <pre><code>rm.solve_model(solver='glpk', save_results=True, results_filename=\"ieee123solved.csv\")\n</code></pre> <p>The solved restoration model can be plotted on a geographical map using the following snippet </p> <pre><code>from ldrestoration.utils.plotnetwork import plot_solution_map\n\n# plot the restoration solution. It requires the solved pyomo model, networkx tree, and\n# networkx graph. The latter two are embedded within the pyomo model for easier access.\nplot_solution_map(rm_solved, rm.network_tree, rm.network_graph)\n</code></pre>"},{"location":"example/quickstart/","title":"Overview","text":"<p>Before diving into this section, please ensure that you have:</p> <ol> <li>successfully installed the ldrestoration package in a new environment and have activated it.</li> <li>Have installed a solver (open source or commercial).</li> <li>have either a working OpenDSS model or CSV input data files compatible with ldrestoration.  </li> </ol> <p>For 1 and 2, please refer to the installation page for more details.</p> <p>The general structure to solve a restoration model, assuming we are starting from the OpenDSS model, is to parse and save the required data structure, formulate the restoration model, solve the restoration model, and create plots or access results for further analysis. The examples on each of these processes can be accessed from examples.</p> <p>Assuming the data is parsed from OpenDSS in the current directory, the optimal power flow for IEEE123 bus system with base model can be executed with the following steps. Here, <code>rm_solved</code> is the solved pyomo restoration model and <code>results</code> is the pyomo results object. </p> <pre><code>from ldrestoration import RestorationBase\n\n# 1. identify the path of the parsed data files\nparsed_data_path = \"parsed_data_iee123/\"\n\n# 2. instantiate the restoration model\nrm = RestorationBase(parsed_data_path, base_kV_LL=4.16)\n\n# 3. identify objective function\nrm.objective_load_only()\n\n# 4. solve the restoration model with the solver of your choice \nrm_solved, results = rm.solve_model(solver='glpk')\n</code></pre>"},{"location":"installation/github/","title":"Installation via GitHub repository","text":"<p>Please follow these steps after you have successfully created an environment for installing the package. Currently, we only support installation via GitHub and will soon release the first version to make the installation possible via pip.</p> <p>The most recent version of LinDistRestoration can be installed from the GitHub repository. You can either visit the repository by navigating the link on the top right corner of this webpage and perform a manual installation or follow the steps below:</p> <ul> <li>Clone the repository to your local folder:</li> </ul> <p>Open a terminal and type the following command. You may need to configure your user settings in Git before you clone the repository. For further information, please follow this link.</p> <pre><code>git clone https://github.com/abodh/LinDistRestoration.git\n</code></pre> <p>This will create a local repository with the folder name <code>ldrestoration</code> in your current directory.</p> <ul> <li>Change the directory to <code>ldrestoration</code>:</li> </ul> <pre><code>cd LinDistRestoration\n</code></pre> <ul> <li>Install the package:</li> </ul> <p><pre><code>python setup.py install\n</code></pre> This should install the latest version of <code>ldrestoration</code> along with the other third-party python packages on which <code>ldrestoration</code> depends. Please install any other packages if you encounter <code>ImportError</code> when running the examples.</p>"},{"location":"installation/installation/","title":"Installation Overview","text":"<p>It is highly recommended for the users to create a separate conda enviroment before proceeding further. LinDistRestoration requires a python version of 3.10 or greater. Please follow the steps below to create a conda environment. Please follow the instructions here to install the latest version of Anaconda. </p>"},{"location":"installation/installation/#creating-a-python-environment","title":"Creating a python environment","text":"<p>If you are in this step, we assume that you have successfully installed Anaconda in your system. While the steps here are specific to Windows users, Linux or Mac users can follow a similar steps accordingly.</p> <p><code>WARNING: LinDistRestoration has not been tested on Linux or Mac as of now.</code></p> <p>Here are the steps to create a new conda environment:</p> <ul> <li>Open Anaconda Prompt from the start menu. The <code>(base)</code> environment should be currently active. It is advised not to use the base environment for any package installations.</li> <li>create a new conda evironment using the following command: <pre><code>conda create -n ldrestoration python=3.10\n</code></pre></li> </ul> <p>This command will create a new environment, <code>ldrestoration</code>, with the specific version of python i.e., <code>3.10.x</code>. Here, the latest version of python 3.10 will be installed. A specific version can be installed with double equal sign i.e., <code>python==3.10.2</code> for example.</p> <ul> <li>activate the environment: The following command will then activate the newly created environment <pre><code>conda activate ldrestoration\n</code></pre> You can then install necessary libraries in this environment to maintain consistency within the same package and avoid any version conflict of the dependent packages with other installations.</li> </ul>"},{"location":"installation/pip/","title":"pip installation","text":"<p>In progress ...</p>"},{"location":"installation/solvers/","title":"Installation of solvers","text":"<p>You can either use open source or commercial solvers. The current version of LinDistRestoration is tested on the following solvers:</p> <ul> <li>Gurobi 10.0.0</li> <li>TBD</li> </ul> <p>The optimization model in LinDistRestoration is based off of Pyomo, which requires solvers to solve the model. For commercial solver, we recommend using Gurobi and if you are an academic researcher, you can leverage their free academic license. For more information please visit their webpage here.</p>"},{"location":"installation/solvers/#open-source-solvers","title":"open source solvers:","text":"<p>At this point, we have not tested any open source solvers and aim to do that in the next release. However, we believe that you can install the following solvers to get started if you do not have access to commercial solver.</p> <ul> <li>GLPK: GLPK (GNU Linear Programming Kit) is an open source solver for linear programming, mixed-integer programming and other related problems. To install <code>glpk</code>, please activate the conda evnironment using <code>conda activate ldrestoration</code> and type the following command:</li> </ul> <pre><code>conda install -c conda-forge glpk\n</code></pre> <ul> <li>CBC: Cbc (Coin-or branch and cut) is an open source solver specially for mixed integer linear programming written in C++. To install <code>cbc</code>, please activate the conda evnironment using <code>conda activate ldrestoration</code> and type the following command:</li> </ul> <pre><code>conda install -c conda-forge coin-or-cbc\n</code></pre> <ul> <li>HiGHS: HiGHS is a high performance serial and parallel solver, which is popular for sparse linear, mixed-integer, and quadratic programming problems.  <pre><code>conda install conda-forge::highs\n</code></pre></li> </ul>"},{"location":"ldrestoration/dssparser/","title":"OpenDSS to LinDistRestoration Parser","text":"<p>DSSManager </p> <p>BusHandler </p> <p>LoadHandler </p> <p>NetworkHandler </p> <p>PDElementHandler </p> <p>TransformerHandler </p>"},{"location":"ldrestoration/dssparser/#ldrestoration.dssparser.dssparser.DSSManager","title":"<code>ldrestoration.dssparser.dssparser.DSSManager</code>","text":"<p>DSSManager is the primary module to parse the OpenDSS data. It manages all the components, including but not limited to, loads, generators, pdelements, transformers etc. Each of the components' data structure is managed by their respective handlers and can be accessed individually, if required.</p> <p>Parameters:</p> Name Type Description Default <code>dssfile</code> <code>str</code> <p>path of the dss master file (currently only supports OpenDSS files)</p> required <code>include_DERs</code> <code>bool</code> <p>Check whether to include DERs or not. Defaults to True.</p> <code>False</code> <code>DER_pf</code> <code>float</code> <p>Constant power factor of DERs. Defaults to 0.9.</p> <code>0.9</code> <code>include_secondary_network</code> <code>bool</code> <p>Check whether to include secondary network or not. Defaults to False.</p> <code>False</code> <p>Examples:</p> <p>The only required argument is the OpenDSS master file. We assume that the master file compiles all other OpenDSS files. The DSSManager class is initiated first and a method parse_dss() will then parse the overall data.</p> <pre><code>&gt;&gt;&gt; dataobj = DSSManager('ieee123master.dss', include_DERs=True)\n&gt;&gt;&gt; dataobj.parse_dss()\n</code></pre> Source code in <code>ldrestoration/dssparser/dssparser.py</code> <pre><code>class DSSManager:\n    \"\"\"DSSManager is the primary module to parse the OpenDSS data. It manages all the components, including but not limited to, loads, generators, pdelements, transformers etc.\n    Each of the components' data structure is managed by their respective handlers and can be accessed individually, if required.\n\n    Args:\n        dssfile (str): path of the dss master file (currently only supports OpenDSS files)\n        include_DERs (bool, optional): Check whether to include DERs or not. Defaults to True.\n        DER_pf (float, optional): Constant power factor of DERs. Defaults to 0.9.\n        include_secondary_network (bool, optional): Check whether to include secondary network or not. Defaults to False.\n\n    Examples:\n        The only required argument is the OpenDSS master file. We assume that the master file compiles all other OpenDSS files.\n        The DSSManager class is initiated first and a method parse_dss() will then parse the overall data.\n        &gt;&gt;&gt; dataobj = DSSManager('ieee123master.dss', include_DERs=True)\n        &gt;&gt;&gt; dataobj.parse_dss()\n\n    \"\"\"\n\n    def __init__(\n        self,\n        dssfile: str,\n        include_DERs: bool = False,\n        DER_pf: float = 0.9,\n        include_secondary_network: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize a DSSManager instance. This instance manages all the components in the distribution system.\n\n        Args:\n            dssfile (str): path of the dss master file (currently only supports OpenDSS files)\n            include_DERs (bool, optional): Check whether to include DERs or not. Defaults to False.\n            DER_pf (float, optional): Constant power factor of DERs. Defaults to 0.9.\n            include_secondary_network (bool, optional): Check whether to include secondary network or not. Defaults to False.\n        \"\"\"\n\n        logger.info(f\"Initializing DSSManager\")\n\n        self.dss = dss\n        self.dssfile = dssfile\n        # opendss direct checks for filenotfound exception so we do not require any exception here\n        self.dss.Text.Command(f\"Redirect {self.dssfile}\")\n\n        # initialize other attributes\n        self.include_DERs = (\n            include_DERs  # variable to check whether to include DERs or not\n        )\n        self.DER_pf = DER_pf  # constant power factor of DERs\n        self.include_secondary_network = (\n            include_secondary_network  # check whether to include secondary or not\n        )\n\n        self.DERs = None  # variable to store information on DERs if included\n        self.pv_systems = None\n\n        self.circuit_data = {}  # store circuit metadata such as source bus, base voltage, etc\n        # initialize parsing process variables and handlers\n        self._initialize()\n\n    @property\n    def bus_names(self) -&gt; list[str]:\n        \"\"\"Access all the bus (node) names from the circuit\n\n        Returns:\n            list[str]: list of all the bus names\n        \"\"\"\n        return self.dss.Circuit.AllBusNames()\n\n    @property\n    def basekV_LL(self) -&gt; float:\n        \"\"\"Returns basekV (line to line) of the circuit based on the sourcebus\n\n        Returns:\n            float: base kV of the circuit as referred to the source bus\n        \"\"\"\n        # make the source bus active before accessing the base kV since there is no provision to get base kV of circuit\n        self.dss.Circuit.SetActiveBus(self.source)\n        return round(self.dss.Bus.kVBase() * np.sqrt(3), 2)\n\n    @property\n    def source(self) -&gt; str:\n        \"\"\"source bus of the circuit.\n\n        Returns:\n            str: returns the source bus of the circuit\n        \"\"\"\n        # typically the first bus is the source bus\n        return self.bus_names[0]\n\n    @timethis\n    def _initialize(self) -&gt; None:\n        \"\"\"\n        Initialize user-based preferences as well as DSS handlers (i.e. load, transformer, pdelements, and network)\n        \"\"\"\n        # if DERs are to be included then include virtual switches for DERs\n        if self.include_DERs:\n            self._initializeDERs()\n            msg_der_initialization = f\"DERs virtual switches have been added successfully. The current version assumes a constant power factor of DERs; DERs power factor = {self.DER_pf}\"\n            logger.info(msg_der_initialization)\n\n            self._initialize_PV()\n            msg_pv_initialization = f\"DERs virtual switches have been added successfully. The current version assumes a constant power factor of DERs; DERs power factor = {self.DER_pf}\"\n            logger.info(msg_pv_initialization)\n\n        else:\n            logger.info(\n                \"DERs virtual switches are not included due to exclusion of DERs.\"\n            )\n\n        # initialize DSS handlers\n        self._initialize_dsshandlers()\n\n        # initialize data variables (these will be dynamically updated through handlers)\n        self.bus_data = None\n        self.transformer_data = None\n        self.pdelements_data = None\n        self.network_graph = None\n        self.network_tree = None\n        self.normally_open_components = None\n        self.load_data = None\n\n    @timethis\n    def _initializeDERs(self) -&gt; None:\n        \"\"\"\n        Include or exclude virtual switches for DERs based on DER inclusion flag\n        \"\"\"\n        self.DERs = []\n        generator_flag = self.dss.Generators.First()\n        while generator_flag:\n            self.dss.Text.Command(\n                \"New Line.{virtual_DERswitch} phases=3 bus1={source_bus} bus2={gen_bus} switch=True r1=0.001 r0=0.001 x1=0.001 x0=0.001 C1=0 C0=0 length=0.001\".format(\n                    virtual_DERswitch=self.dss.Generators.Name(),\n                    source_bus=self.source,\n                    gen_bus=self.dss.Generators.Bus1(),\n                )\n            )\n            self.DERs.append(\n                {\n                    \"name\": self.dss.Generators.Name(),\n                    \"kW_rated\": round(self.dss.Generators.kVARated() * self.DER_pf, 2),\n                    \"connected_bus\": self.dss.Generators.Bus1(),\n                    \"phases\": self.dss.Generators.Phases(),\n                }\n            )\n\n            generator_flag = self.dss.Generators.Next()\n\n        # we also need to ensure that these switches are open as they are virtual switches\n        for each_DERs in self.DERs:\n            self.dss.Text.Command(f'Open Line.{each_DERs[\"name\"]}')\n\n        self.dss.Solution.Solve()\n\n    @timethis\n    def _initialize_PV(self) -&gt; None:\n        \"\"\"\n        Include PV Systems from the dss data\n        \"\"\"\n        self.pv_systems = []\n        pv_flag = self.dss.PVsystems.First()\n        while pv_flag:\n            self.pv_systems.append(\n                {\n                    \"name\": self.dss.PVsystems.Name(),\n                    \"kW_rated\": round(\n                        self.dss.PVsystems.kVARated() * self.dss.PVsystems.pf(), 2\n                    ),\n                    \"connected_bus\": self.dss.CktElement.BusNames()[0],\n                    \"phases\": self.dss.CktElement.NumPhases(),\n                }\n            )\n\n            pv_flag = self.dss.PVsystems.Next()\n\n    @timethis\n    def _initialize_dsshandlers(self) -&gt; None:\n        \"\"\"Initialize all the DSS Handlers\"\"\"\n\n        # bus_handler is currently not being used here but kept here for future usage\n        self.bus_handler = BusHandler(self.dss)\n        self.transformer_handler = TransformerHandler(self.dss)\n        self.pdelement_handler = PDElementHandler(self.dss)\n        self.network_handler = NetworkHandler(\n            self.dss, pdelement_handler=self.pdelement_handler\n        )\n\n        if self.include_secondary_network:\n            logger.info(\"Considering entire system including secondary networks\")\n            self.load_handler = LoadHandler(\n                self.dss, include_secondary_network=self.include_secondary_network\n            )\n        else:\n            # if primary loads are to be referred then we must pass network and transformer handlers\n            logger.info(\n                \"Considering primary networks and aggregating loads by referring them to the primary node\"\n            )\n            self.load_handler = LoadHandler(\n                self.dss,\n                include_secondary_network=self.include_secondary_network,\n                network_handler=self.network_handler,\n                transformer_handler=self.transformer_handler,\n            )\n        logger.info(\n            f'Successfully instantiated required handlers from \"{self.dssfile}\"'\n        )\n\n    @timethis\n    def parsedss(self) -&gt; None:\n        \"\"\"Parse required data from the handlers to respective class variables\"\"\"\n        self.bus_data = self.bus_handler.get_buses()\n        self.transformer_data = self.transformer_handler.get_transformers()\n        self.pdelements_data = self.pdelement_handler.get_pdelements()\n        self.network_graph, self.network_tree, self.normally_open_components = (\n            self.network_handler.network_topology()\n        )\n        self.load_data = self.load_handler.get_loads()\n\n        if not self.include_secondary_network:\n            logger.info(\n                f\"Excluding secondaries from final tree, graph configurations, and pdelements.\"\n            )\n            self.network_tree.remove_nodes_from(\n                self.load_handler.downstream_nodes_from_primary\n            )\n            self.network_graph.remove_nodes_from(\n                self.load_handler.downstream_nodes_from_primary\n            )\n            self.pdelements_data = [\n                items\n                for items in self.pdelements_data\n                if items[\"from_bus\"]\n                not in self.load_handler.downstream_nodes_from_primary\n                and items[\"to_bus\"]\n                not in self.load_handler.downstream_nodes_from_primary\n            ]\n        logger.info(f\"Successfully parsed the required data from all handlers.\")\n\n        # the networkx data is saved as a serialized JSON\n        self.network_graph_data = json_graph.node_link_data(self.network_graph)\n        self.network_tree_data = json_graph.node_link_data(self.network_tree)\n\n        # parse additional circuit data\n        # add more as required in the future ...\n        self.circuit_data = {\n            \"substation\": self.source,\n            \"basekV_LL_circuit\": self.basekV_LL,\n        }\n\n    @timethis\n    def saveparseddss(\n        self, folder_name: str = f\"parsed_data\", folder_exist_ok: bool = False\n    ) -&gt; None:\n        \"\"\"Saves the parsed data from all the handlers\n\n        Args:\n            folder_name (str, optional): Name of the folder to save the data in. Defaults to \"dssdatatocsv\"_&lt;current system date&gt;.\n            folder_exist_ok (bool, optional): Boolean to check if folder rewrite is ok. Defaults to False.\n        \"\"\"\n\n        # check if parsedss is run before saving these files\n        if self.bus_data is None:\n            logger.error(\n                \"Please run DSSManager.parsedss() to parse the data and then run this function to save the files.\"\n            )\n            raise NotImplementedError(\n                f\"Data variables are empty. You must run {__name__}.DSSManager.parsedss() to extract the data before saving them.\"\n            )\n\n        # check if the path already exists. This prevent overwrite\n        try:\n            Path(folder_name).mkdir(parents=True, exist_ok=folder_exist_ok)\n        except FileExistsError:\n            logger.error(\n                \"The folder already exists and the module is attempting to rewrite the data in the folder. Either provide a path in &lt;folder_name&gt; or mention &lt;folder_exist_ok=True&gt; to rewrite the existing files.\"\n            )\n            raise FileExistsError(\n                \"The folder or files already exist. Please provide a non-existent path.\"\n            )\n\n        # save all the data in the new folder\n        # the non-networkx data are all saved as dataframe in csv\n        pd.DataFrame(self.bus_data).to_csv(f\"{folder_name}/bus_data.csv\", index=False)\n        pd.DataFrame(self.transformer_data).to_csv(\n            f\"{folder_name}/transformer_data.csv\", index=False\n        )\n        pd.DataFrame(self.pdelements_data).to_csv(\n            f\"{folder_name}/pdelements_data.csv\", index=False\n        )\n        pd.DataFrame(self.load_data).to_csv(f\"{folder_name}/load_data.csv\", index=False)\n        pd.DataFrame(\n            self.normally_open_components, columns=[\"normally_open_components\"]\n        ).to_csv(f\"{folder_name}/normally_open_components.csv\", index=False)\n\n        if self.DERs is not None:\n            pd.DataFrame(self.DERs).to_csv(f\"{folder_name}/DERs.csv\", index=False)\n            pd.DataFrame(self.pv_systems).to_csv(\n                f\"{folder_name}/pv_systems.csv\", index=False\n            )\n\n        with open(f\"{folder_name}/network_graph_data.json\", \"w\") as file:\n            json.dump(self.network_graph_data, file)\n\n        with open(f\"{folder_name}/network_tree_data.json\", \"w\") as file:\n            json.dump(self.network_tree_data, file)\n\n        # save the circuit data as json\n        with open(f\"{folder_name}/circuit_data.json\", \"w\") as file:\n            json.dump(self.circuit_data, file)\n\n        logger.info(\"Successfully saved required files.\")\n</code></pre>"},{"location":"ldrestoration/dssparser/#ldrestoration.dssparser.bushandler.BusHandler","title":"<code>ldrestoration.dssparser.bushandler.BusHandler</code>","text":"<p>BusHandler deals with bus (node) related data from the distribution model.</p> <p>Parameters:</p> Name Type Description Default <code>dss_instance</code> <code>ModuleType</code> <p>redirected opendssdirect instance </p> required Note <p>Bus and Nodes are two different concepts in distribution systems modeling and are used interchangably here  for simplicity.</p> Source code in <code>ldrestoration/dssparser/bushandler.py</code> <pre><code>class BusHandler:\n    \"\"\"BusHandler deals with bus (node) related data from the distribution model.\n\n    Args:\n        dss_instance (ModuleType): redirected opendssdirect instance \n\n    Note: \n        Bus and Nodes are two different concepts in distribution systems modeling and are used interchangably here \n        for simplicity.    \n    \"\"\"\n\n    def __init__(self, \n                 dss_instance: ModuleType) -&gt; None:\n        \"\"\"Initialize a BusHandler instance. This instance deals with bus (node) related data from the distribution model.\n        Note: Bus and Nodes are two different concepts in distribution systems modeling and are used interchangably here \n        for simplicity.\n\n        Args:\n            dss_instance (ModuleType): redirected opendssdirect instance \n        \"\"\"\n\n        self.dss_instance = dss_instance \n\n    @timethis\n    def get_buses(self) -&gt; list[dict[str,Union[int,str,float]]]: \n        \"\"\"Extract the bus data -&gt; name, basekV, latitude, longitude from the distribution model.\n\n        Returns:\n            bus_data (list[dict[str,Union[int,str,float]]]): list of bus data for each buses\n        \"\"\"\n        all_buses_names = self.dss_instance.Circuit.AllBusNames()        \n        bus_data = []        \n        for bus in all_buses_names:\n\n            # need to set the nodes active before extracting their info \n            self.dss_instance.Circuit.SetActiveBus(bus)\n\n            # be careful that X gives you lon and Y gives you lat\n            bus_coordinates = dict(name = self.dss_instance.Bus.Name(),\n                                   basekV = round(self.dss_instance.Bus.kVBase(),2),\n                                   latitude = self.dss_instance.Bus.Y(),\n                                   longitude = self.dss_instance.Bus.X())\n\n            bus_data.append(bus_coordinates)\n        return bus_data\n</code></pre>"},{"location":"ldrestoration/dssparser/#ldrestoration.dssparser.loadhandler.LoadHandler","title":"<code>ldrestoration.dssparser.loadhandler.LoadHandler</code>","text":"<p>LoadHandler deals with all the loads in the distribution system.  When <code>include_secondary_network=False</code>, all the secondary loads are referred back to their primary.  </p> <p>Parameters:</p> Name Type Description Default <code>dss_instance</code> <code>ModuleType</code> <p>redirected opendssdirect instance</p> required <code>network_handler</code> <code>Optional[NetworkHandler]</code> <p>Directed network tree of the distribution model, Defaults to None</p> <code>None</code> <code>transformer_handler</code> <code>Optional[TransformerHandler]</code> <p>Instance of TransformerHandler. Defaults to None.</p> <code>None</code> <code>include_secondary_network</code> <code>Optional[bool]</code> <p>Whether the secondary network is to be considered or not, Defaults to False</p> <code>False</code> <code>bus_names</code> <code>Optional[list[str]]</code> <p>Names of all the buses (nodes) in the distribution model</p> <code>None</code> Note <ul> <li>In OpenDSS, the phases information of loads are lost on the secondary side of the split-phase transformers. Hence, each of the loads are traced back to their  nearest transformer to identify the corresponding phase. For delta primary, the loads are equally distributed to each phase. </li> </ul> To do <ul> <li>The current version does not address phase wise load decoupling for delta connected loads. It will be incorporated in the future releases.</li> </ul> Source code in <code>ldrestoration/dssparser/loadhandler.py</code> <pre><code>class LoadHandler:\n    \"\"\"LoadHandler deals with all the loads in the distribution system. \n    When `include_secondary_network=False`, all the secondary loads are referred back to their primary.  \n\n    Args:\n        dss_instance (ModuleType): redirected opendssdirect instance\n        network_handler (Optional[NetworkHandler]): Directed network tree of the distribution model, Defaults to None\n        transformer_handler (Optional[TransformerHandler]): Instance of TransformerHandler. Defaults to None.\n        include_secondary_network (Optional[bool]): Whether the secondary network is to be considered or not, Defaults to False\n        bus_names (Optional[list[str]]):Names of all the buses (nodes) in the distribution model\n\n    Note:\n        * In OpenDSS, the phases information of loads are lost on the secondary side of the split-phase transformers. Hence, each of the loads are traced back to their \n        nearest transformer to identify the corresponding phase. For delta primary, the loads are equally distributed to each phase. \n\n    To do:\n        * The current version does not address phase wise load decoupling for delta connected loads. It will be incorporated in the future releases.\n\n    \"\"\"     \n\n    def __init__(self, \n                 dss_instance: ModuleType,\n                 network_handler: Optional[NetworkHandler] = None,\n                 transformer_handler: Optional[TransformerHandler] = None, \n                 include_secondary_network: Optional[bool] = False,                 \n                 bus_names: Optional[list[str]] = None) -&gt; None:\n\n        \"\"\"Initialize a LoadHandler instance. This instance deals with all the loads in the distribution system. \n\n        Args:\n            dss_instance (ModuleType): redirected opendssdirect instance\n            network_handler (Optional[NetworkHandler]): Directed network tree of the distribution model, Defaults to None\n            transformer_handler (Optional[TransformerHandler]): Instance of TransformerHandler. Defaults to None.\n            include_secondary_network (Optional[bool]): Whether the secondary network is to be considered or not, Defaults to False\n            bus_names (Optional[list[str]]):Names of all the buses (nodes) in the distribution model\n        \"\"\"        \n\n        self.dss_instance = dss_instance         \n        self.network_handler = network_handler\n        self.transformer_handler = transformer_handler\n        self.include_secondary_network = include_secondary_network\n\n        # since bus_names is required for any methods in LoadHandler, we rather check it in the initialization\n        self.bus_names = self.dss_instance.Circuit.AllBusNames() if bus_names is None else bus_names        \n        self.downstream_nodes_from_primary = None\n\n        # validate if the required inputs are in existence\n        self.__load_input_validator()\n\n    @timethis\n    def __load_input_validator(self) -&gt; None:\n            \"\"\"This is to be checked in the future. Network and Transformer handler should be optional\n            and only available if loads are to be referred to the primary.\"\"\"\n\n            if not self.include_secondary_network and (not self.transformer_handler and not self.network_handler):\n                # if we do not want secondary and we do not pass any handlers then there must be an error\n                logger.warning(\"You need to provide NetworkHandler() and TransformerHandler as arguments to LoadHandler()\")\n                raise NotImplementedError(\n                \"To refer the loads to primary, both NetworkHandler and TransformerHandler are required.\"\n                )  \n\n    @timethis\n    def get_loads(self) -&gt; pd.DataFrame:\n\n        if self.include_secondary_network:\n            # get all loads as they appear in the secondary\n            logger.info(\"Fetching the loads as they appear on the secondary\")\n            return self.get_all_loads()\n        else:\n            # get primarry referred loads\n            logger.info(\"Referring the loads back to the primary node of the distribution transformer.\")\n            return self.get_primary_referred_loads()             \n\n    @property\n    @cache\n    def bus_names_to_index_map(self) -&gt; dict[str,int]:\n        \"\"\"each of the bus mapped to its corresponding index in the bus names list\n\n        Returns:\n            dict[str,int]: dictionary with key as bus names and value as its index\n        \"\"\"        \n        return {bus:index for index,bus in enumerate(self.bus_names)}\n\n    @timethis    \n    def get_all_loads(self) -&gt; pd.DataFrame:\n        \"\"\"Extract load information for each bus(node) for each phase. This method extracts load on the exact bus(node) as \n        modeled in the distribution model, including secondary.\n\n        Returns:\n            load_per_phase(pd.DataFrame): Per phase load data in a pandas dataframe\n        \"\"\"\n\n        num_buses = len(self.bus_names)\n\n        # Initialize arrays for load_per_phase\n        load_per_phase = {\n            \"name\": [\"\"] * num_buses,\n            \"bus\": self.bus_names,\n            \"P1\": np.zeros(num_buses),\n            \"Q1\": np.zeros(num_buses),\n            \"P2\": np.zeros(num_buses),\n            \"Q2\": np.zeros(num_buses),\n            \"P3\": np.zeros(num_buses),\n            \"Q3\": np.zeros(num_buses)\n        }\n\n        loads_flag = self.dss_instance.Loads.First()\n\n        while loads_flag:\n            connected_buses = self.dss_instance.CktElement.BusNames()           \n\n            # conductor power contains info on active and reactive power\n            conductor_power = np.array(self.dss_instance.CktElement.Powers())\n            nonzero_power_indices = np.where(conductor_power != 0)[0]\n            nonzero_power = conductor_power[nonzero_power_indices]\n\n            for buses in connected_buses:\n                bus_split = buses.split(\".\")\n                if (len(bus_split) == 4) or (len(bus_split) == 1):\n\n                    # three phase checker\n                    connected_bus = bus_split[0]\n                    bus_index = self.bus_names_to_index_map[connected_bus]\n                    load_per_phase[\"name\"][bus_index] = self.dss_instance.Loads.Name()\n                    P_values = nonzero_power[::2]   # Extract P values (every other element starting from the first)\n                    Q_values = nonzero_power[1::2]  # Extract Q values (every other element starting from the second)\n                    for phase_index in range(3):\n                        load_per_phase[f\"P{phase_index + 1}\"][bus_index] += round(P_values[phase_index],2)\n                        load_per_phase[f\"Q{phase_index + 1}\"][bus_index] += round(Q_values[phase_index],2)\n\n                else:\n                    # non three phase load\n                    connected_bus, connected_phase_secondary = bus_split[0], bus_split[1:]\n                    bus_index = self.bus_names_to_index_map[connected_bus]                  \n                    load_per_phase[\"name\"][bus_index] = self.dss_instance.Loads.Name()\n                    P_values = nonzero_power[::2]  # Extract P values (every alternate element starting from the first)\n                    Q_values = nonzero_power[1::2]  # Extract Q values (every alternate element starting from the second)\n\n                    for phase_index, phase in enumerate(connected_phase_secondary):\n                        load_per_phase[f\"P{phase}\"][bus_index] += round(P_values[phase_index], 2)\n                        load_per_phase[f\"Q{phase}\"][bus_index] += round(Q_values[phase_index], 2)\n\n            loads_flag = self.dss_instance.Loads.Next()\n\n        return pd.DataFrame(load_per_phase)        \n\n    @timethis\n    def get_primary_referred_loads(self) -&gt; pd.DataFrame:\n        \"\"\"Transfer all the secondary nodes to the primary corresponding to each split phase transformer. \n        Also returns the downstream nodes from the split phase transformers.\n\n        Returns:\n            primary_loads_df(pd.DataFrame): Per phase load data in a pandas dataframe with secondary transferred to primary\n        \"\"\"\n        # keep track of all downstream nodes from primary. This is for removal from network as well,\n        # since we are aggregating these loads in the primary, removing them will reduce computational burden\n        self.downstream_nodes_from_primary = set()  \n\n        # get access to the network tree from the topology\n        _, network_tree, _ = self.network_handler.network_topology()\n\n        # obtain the relation between the primary phase and secondary bus in splitphase transformer\n        # this obtains a dictionary with secondary nodes s key and their associated phase info as value\n        split_phase_primary = self.transformer_handler.get_splitphase_primary()\n\n        # initially this is the secondary load but will be changed to reflect the primary load referral\n        primary_loads_df = self.get_all_loads()   \n\n        for xfrmr_secondary_node, primary_phase in split_phase_primary.items():\n\n            # here we get the predecessor of the secondary i.e. primary node\n            xfrmr_primary_node = list(network_tree.predecessors(xfrmr_secondary_node))[0]\n\n            # identify the secondary and primary bus indices so that loads are referred to primary             \n            secondary_bus_index = self.bus_names_to_index_map[xfrmr_secondary_node]\n            primary_bus_index = self.bus_names_to_index_map[xfrmr_primary_node]\n\n            # however we still traverse downstream from the secondary as traversing from primary could follow other routes too\n            xfrmr_downstream_nodes = nx.descendants(network_tree, xfrmr_secondary_node)\n            xfrmr_downstream_nodes.add(xfrmr_secondary_node)\n\n            # add all the nodes downstream from the transformer's primary (including secondary)\n            self.downstream_nodes_from_primary.update(xfrmr_downstream_nodes)      \n\n            # now we refer all the downstream node loads (if available) to the primary and remove them from the load df\n            # this reduces computational burden when not dealing with the secondaries\n            for xfrmr_downstream_node in xfrmr_downstream_nodes:   \n                try:\n                    downstream_node_index = self.bus_names_to_index_map[xfrmr_downstream_node]\n                except KeyError:\n                    logger.error(f\"Invalid load name {xfrmr_downstream_node}\")\n                    raise KeyError(f\"{xfrmr_downstream_node} is not a valid node name.\")\n\n                primary_loads_df.loc[primary_bus_index, f\"P{primary_phase[0]}\"] += (primary_loads_df[\"P1\"][downstream_node_index] +\n                                                                                    primary_loads_df[\"P2\"][downstream_node_index]) \n                primary_loads_df.loc[primary_bus_index, f\"Q{primary_phase[0]}\"] += (primary_loads_df[\"Q1\"][downstream_node_index] +\n                                                                                    primary_loads_df[\"Q2\"][downstream_node_index])                \n\n                primary_loads_df.loc[primary_bus_index, f\"name\"] = primary_loads_df[\"name\"][downstream_node_index]\n\n                # drop the secondaries from the dataframe\n                primary_loads_df.drop(downstream_node_index, inplace=True) \n                # primary_loads_df.drop(secondary_bus_index, inplace=True)  \n\n        # reset the loads dataframe to its original index\n        primary_loads_df.reset_index(inplace=True, drop=True)\n\n        return primary_loads_df \n</code></pre>"},{"location":"ldrestoration/dssparser/#ldrestoration.dssparser.networkhandler.NetworkHandler","title":"<code>ldrestoration.dssparser.networkhandler.NetworkHandler</code>","text":"<p>NetworkHandler creates and modifies the network as a graph (nodes and edges) for the distribution model </p> <p>Parameters:</p> Name Type Description Default <code>dss_instance</code> <code>ModuleType</code> <p>redirected opendssdirect instance</p> required <code>bus_names</code> <code>Optional[list[str]]</code> <p>Names of all the buses (nodes) in the distribution model. Defaults to None</p> <code>None</code> <code>source</code> <code>Optional[str]</code> <p>Source node of the graph to build. Defaults to None.</p> <code>None</code> <code>pdelement_handler</code> <code>Optional[PDElementHandler]</code> <p>Instance of PDElementHandler. Defaults to None.</p> <code>None</code> <code>pdelements_data</code> <code>Optional[list[dict[str, Union[int, str, float]]]]</code> <p>All the required data of the pdelements(edges) from PDElementHandler or provided by user in pdelements format. Defaults to None.</p> <code>None</code> To do <ul> <li>extract feeder information to visualize it better</li> <li>add a method to remove list of edges provided as an argument</li> </ul> Source code in <code>ldrestoration/dssparser/networkhandler.py</code> <pre><code>class NetworkHandler:\n\n    \"\"\"NetworkHandler creates and modifies the network as a graph (nodes and edges) for the distribution model \n\n    Args:\n        dss_instance (ModuleType): redirected opendssdirect instance\n        bus_names (Optional[list[str]]):Names of all the buses (nodes) in the distribution model. Defaults to None\n        source (Optional[str], optional): Source node of the graph to build. Defaults to None.\n        pdelement_handler (Optional[PDElementHandler], optional): Instance of PDElementHandler. Defaults to None.\n        pdelements_data (Optional[list[dict[str,Union[int,str,float]]]], optional): All the required data of the pdelements(edges) from PDElementHandler or provided by user in pdelements format. Defaults to None.\n\n    To do:\n        * extract feeder information to visualize it better\n        * add a method to remove list of edges provided as an argument\n    \"\"\"   \n    def __init__(self, \n                 dss_instance: ModuleType, \n                 bus_names: Optional[list[str]] = None,\n                 source: Optional[str] = None,\n                 pdelement_handler: Optional[PDElementHandler] = None,\n                 pdelements_data: Optional[list[dict[str,Union[int,str,float, npt.NDArray[np.complex128]]]]] = None) -&gt; None:\n\n        \"\"\"Initialize a NetworkHandler instance. Create and modify the network as a graph (nodes and edges) for the distribution model \n\n        Args:\n            dss_instance (ModuleType): redirected opendssdirect instance\n            bus_names (Optional[list[str]]):Names of all the buses (nodes) in the distribution model. Defaults to None\n            source (Optional[str], optional): Source node of the graph to build. Defaults to None.\n            pdelement_handler (Optional[PDElementHandler], optional): Instance of PDElementHandler. Defaults to None.\n            pdelements_data (Optional[list[dict[str,Union[int,str,float]]]], optional): All the required data of the pdelements(edges) \n            from PDElementHandler or provided by user in pdelements format. Defaults to None.\n        \"\"\"                      \n\n        self.dss_instance = dss_instance \n        self.bus_names = bus_names\n        self.source = source        \n        self.pdelements_data = pdelements_data\n        self.pdelement_handler = pdelement_handler\n\n    def __network_input_validator(self) -&gt; None:\n        \"\"\"Validates the data required to build a network\n\n        Raises:\n            NotImplementedError (elements): This is raised when pdelements data are not provided (either json or PDElementHandler)\n            EOFError (source): This is raised when a source does not exist in the tree i.e. the bus of the distribution model\n        \"\"\"        \n        if self.bus_names is None:\n            logger.info(\"Bus names not provided. So extracting it from the base network.\")\n            self.bus_names = self.dss_instance.Circuit.AllBusNames()\n\n        if self.pdelements_data is None and self.pdelement_handler is None:\n            logger.warning(\"You need to provide either one of the following: pcelement list of dicts or PCElementHandler\")\n            raise NotImplementedError(\n                \"Please provide an element file (json) OR PDElement instance from PDElement handler to create the network.\"\n                )\n\n        if self.source is not None and self.source not in self.bus_names:\n            logger.warning(\"The source must be one of the existing buses (nodes) in the distribution model.\")\n            raise EOFError(\n                \"Please provide a valid source. A source must be an existing bus (node) in the distribution model\"\n                )\n\n    def __set_node_coordinates(self, network_tree: nx.DiGraph) -&gt; None:\n        \"\"\"Sets the coordinates of each nodes as per the bus coordinates data\n\n        Args:\n            network_tree (nx.DiGraph): A directed graph (network tree in this case)\n        \"\"\"\n\n        for node in network_tree.nodes():\n\n            # need to set the nodes active before extracting their info \n            self.dss_instance.Circuit.SetActiveBus(node)\n\n            # be careful that X gives you lon and Y gives you lat\n            network_tree.nodes[node]['lat'] = self.dss_instance.Bus.Y()\n            network_tree.nodes[node]['lon'] = self.dss_instance.Bus.X()\n\n\n    def build_network(self, all_pdelements: list[dict[str,Union[int,str,float, npt.NDArray[np.complex128]]]]) -&gt; tuple[nx.Graph, list[str]]: \n        \"\"\"Build the network from the pdelements data\n\n        Args:\n            all_pdelements (list[dict[str,Union[int,str,float, npt.NDArray[np.complex128]]]]): All the required data of the pdelements(edges) \n            from PDElementHandler or provided by user in pdelements format.\n\n        Returns:\n            network_graph (nx.Graph): Network graph (undirected) \n            normally_open_components (list[str]): Names of normally open pdelements (tie or virtual switches) \n        \"\"\"         \n\n        # initiate a network graph. Since the power flow occurs in any direction this should be undirected\n        network_graph = nx.Graph()\n\n        # extract normally open components\n        normally_open_components = []\n\n        # add lines as graph edges. initial version may have loops so we create graphs and then create trees\n        for each_line in all_pdelements:\n            if not each_line['is_open']:\n                network_graph.add_edge(each_line['from_bus'],\n                                       each_line['to_bus'], \n                                       # the remaining arguments are the data associated with each edges\n                                       element=each_line['element'],\n                                       is_switch=each_line['is_switch'],\n                                       is_open=each_line['is_open'],\n                                       name=each_line['name'])\n            else:\n                normally_open_components.append(each_line['name'])\n\n        return network_graph, normally_open_components          \n\n    def network_topology(self) -&gt; tuple[nx.Graph, nx.DiGraph, list[str]]:\n        \"\"\"Create network topology including graph, trees, and open components\n\n        Returns:\n            network_graph (nx.Graph): Undirected network graph\n            network_tree (list[str]): Directed network tree\n            normally_open_components (list[str]): Names of normally open pdelements (tie or virtual switches)\n        \"\"\"\n\n        # validate the data first i.e. whether pdelements were provided or not\n        self.__network_input_validator()\n        self.source = self.bus_names[0]\n\n        # this can be user defined lines or can be extracted from the base network using PDElementHandler\n        all_pdelements = self.pdelement_handler.get_pdelements() if not self.pdelements_data else self.pdelements_data\n\n        network_graph, normally_open_components = self.build_network(all_pdelements)\n        network_tree = nx.bfs_tree(network_graph, source=self.source)\n\n        # add the bus corrdinates from dss to network tree\n        self.__set_node_coordinates(network_tree)   \n\n        return network_graph, network_tree, normally_open_components\n</code></pre>"},{"location":"ldrestoration/dssparser/#ldrestoration.dssparser.pdelementshandler.PDElementHandler","title":"<code>ldrestoration.dssparser.pdelementshandler.PDElementHandler</code>","text":"<p>PDElementHandler deals with all the power delivery elements -&gt; lines, transformers, reactors, and capacitors. ALthough we have separate handlers for a few of them, we extract the PDelements here as they represent edges for out network</p> <p>Parameters:</p> Name Type Description Default <code>dss_instance</code> <code>ModuleType</code> <p>redirected opendssdirect instance</p> required Source code in <code>ldrestoration/dssparser/pdelementshandler.py</code> <pre><code>class PDElementHandler:\n    \"\"\"PDElementHandler deals with all the power delivery elements -&gt; lines, transformers,\n    reactors, and capacitors. ALthough we have separate handlers for a few of them, we extract the PDelements here as they represent\n    edges for out network\n\n    Args:\n        dss_instance (ModuleType): redirected opendssdirect instance\n    \"\"\"\n\n    def __init__(self, dss_instance: ModuleType) -&gt; None:\n        \"\"\"Initialize a PDElementHandler instance. This instance deals with all the power delivery elements -&gt; lines, transformers,\n        reactors, and capacitors. ALthough we have separate handlers for a few of them, we extract the PDelements here as they represent\n        edges for out network\n\n        Args:\n            dss_instance (ModuleType): redirected opendssdirect instance\n        \"\"\"\n\n        self.dss_instance = dss_instance\n\n    def __get_line_zmatrix(self) -&gt; tuple[np.ndarray, np.ndarray]:\n        \"\"\"Returns the z_matrix of a specified line element.\n\n        Returns:\n            real z_matrix, imag z_matrix (np.ndarray, np.ndarray): 3x3 numpy array of the z_matrix corresponding to the each of the phases(real,imag)\n        \"\"\"\n\n        if (len(self.dss_instance.CktElement.BusNames()[0].split(\".\")) == 4) or (\n            len(self.dss_instance.CktElement.BusNames()[0].split(\".\")) == 1\n        ):\n\n            # this is the condition check for three phase since three phase is either represented by bus_name.1.2.3 or bus_name\n            z_matrix = np.array(self.dss_instance.Lines.RMatrix()) + 1j * np.array(\n                self.dss_instance.Lines.XMatrix()\n            )\n            z_matrix = z_matrix.reshape(3, 3)\n\n            return np.real(z_matrix), np.imag(z_matrix)\n\n        else:\n\n            # for other than 3 phases\n            active_phases = [\n                int(phase)\n                for phase in self.dss_instance.CktElement.BusNames()[0].split(\".\")[1:]\n            ]\n            z_matrix = np.zeros((3, 3), dtype=complex)\n            r_matrix = self.dss_instance.Lines.RMatrix()\n            x_matrix = self.dss_instance.Lines.XMatrix()\n            counter = 0\n            for _, row in enumerate(active_phases):\n                for _, col in enumerate(active_phases):\n                    z_matrix[row - 1, col - 1] = complex(\n                        r_matrix[counter], x_matrix[counter]\n                    )\n                    counter = counter + 1\n\n            return np.real(z_matrix), np.imag(z_matrix)\n\n    def __get_nonline_zmatrix(self) -&gt; list[list[float]]:\n        \"\"\"Returns the z_matrix of a specified element other than the line element.\n\n        Returns:\n            z_matrix (list[list[float]]): list of list of float of z matrices (same fo real and imag)\n        \"\"\"\n        # hash map for the element z matrices other than lines\n        # this is temporary and should be fixed later to replace with the actual impedances of the element.\n        elements_z_matrix = {\n            (\"1\",): [[0.001, 0, 0], [0, 0, 0], [0, 0, 0]],\n            (\"2\",): [[0, 0, 0], [0, 0.001, 0], [0, 0, 0]],\n            (\"3\",): [[0, 0, 0], [0, 0, 0], [0, 0, 0.001]],\n            (\"1\", \"2\"): [[0.001, 0, 0], [0, 0.001, 0], [0, 0, 0]],\n            (\"2\", \"3\"): [[0, 0, 0], [0, 0.001, 0], [0, 0, 0.001]],\n            (\"1\", \"3\"): [[0.001, 0, 0], [0, 0, 0], [0, 0, 0.001]],\n            (\"1\", \"2\", \"3\"): [[0.001, 0, 0], [0, 0.001, 0], [0, 0, 0.001]],\n        }\n\n        if self.dss_instance.CktElement.NumPhases() == 3:\n            return elements_z_matrix[(\"1\", \"2\", \"3\")]\n        else:\n            bus_phases = self.dss_instance.CktElement.BusNames()[0].split(\".\")[1:]\n            return elements_z_matrix[tuple(bus_phases)]\n\n    def element_phase_identification(self, element_phases=list[str]) -&gt; list[str]:\n        \"\"\"Match the phase from the number convention to letter convention i.e. 123 -&gt; abc\n\n        Returns:\n            set[str]: set of phases converted to letter type\n        \"\"\"\n        # create a dict of mapper\n        phasemap = {\"1\": \"a\", \"2\": \"b\", \"3\": \"c\"}\n\n        # identify and return corresponding dss phases in numbers to the letters\n        return {phasemap[dss_phase] for dss_phase in element_phases}\n\n    @cached_property\n    def transformer_rating(self) -&gt; int:\n        \"\"\"Obtain transformer rating for each transformer\n\n        Returns:\n            int: Rating of the transformer in kVA (assume this to be kW for now)\n        \"\"\"\n\n        each_transformer_rating = {}\n        flag = self.dss_instance.Transformers.First()\n        while flag:\n            transformer_name = self.dss_instance.Transformers.Name()\n            each_transformer_rating[transformer_name] = (\n                self.dss_instance.Transformers.kVA()\n            )\n            flag = self.dss_instance.Transformers.Next()\n\n        return each_transformer_rating\n\n    def get_pdelements(self) -&gt; list[dict[str, Union[int, str, float, np.ndarray]]]:\n        \"\"\"Extract the list of PDElement from the distribution model. Capacitors are excluded.\n\n        Returns:\n            pdelement_list (list[dict[str,Union[int,str,float, np.ndarray]]]):\n            list of pdelements with required information\n        \"\"\"\n\n        element_activity_status = self.dss_instance.PDElements.First()\n        pdelement_list = []\n\n        while element_activity_status:\n            element_type = self.dss_instance.CktElement.Name().lower().split(\".\")[0]\n\n            # capacitor is a shunt element  and is not included\n            if element_type != \"capacitor\":\n                # \"Capacitors are shunt elements and are not modeled in this work. Regulators are not modeled as well.\"\n                if element_type == \"line\":\n                    z_matrix_real, z_matrix_imag = self.__get_line_zmatrix()\n                    each_element_data = {\n                        \"name\": self.dss_instance.Lines.Name(),\n                        \"element\": element_type,\n                        # from opendss manual -&gt; length units = {none|mi|kft|km|m|ft|in|cm}\n                        \"length_unit\": self.dss_instance.Lines.Units(),\n                        \"z_matrix_real\": z_matrix_real.tolist(),\n                        \"z_matrix_imag\": z_matrix_imag.tolist(),\n                        \"length\": self.dss_instance.Lines.Length(),\n                        \"from_bus\": self.dss_instance.Lines.Bus1().split(\".\")[0],\n                        \"to_bus\": self.dss_instance.Lines.Bus2().split(\".\")[0],\n                        \"num_phases\": self.dss_instance.Lines.Phases(),\n                        \"phases\": (\n                            {\"a\", \"b\", \"c\"}\n                            if self.dss_instance.CktElement.NumPhases() == 3\n                            else self.element_phase_identification(\n                                element_phases=self.dss_instance.CktElement.BusNames()[\n                                    0\n                                ].split(\".\")[1:]\n                            )\n                        ),\n                        \"is_switch\": self.dss_instance.Lines.IsSwitch(),\n                        \"is_open\": (\n                            self.dss_instance.CktElement.IsOpen(1, 0)\n                            or self.dss_instance.CktElement.IsOpen(2, 0)\n                        ),\n                    }\n                    # obtain the kVbase (line to line) of the element\n                    # we assume the voltage level of the element is the voltage of its secondary bus\n\n                    self.dss_instance.Circuit.SetActiveBus(\n                        self.dss_instance.Lines.Bus2().split(\".\")[0]\n                    )\n                    each_element_data[\"base_kv_LL\"] = round(\n                        self.dss_instance.Bus.kVBase() * np.sqrt(3), 2\n                    )\n\n                    # the loading is per conductor\n                    each_element_data[\"normal_loading_kW\"] = (\n                        each_element_data[\"base_kv_LL\"]\n                        / np.sqrt(3)\n                        * self.dss_instance.Lines.NormAmps()\n                        if each_element_data[\"num_phases\"] == 1\n                        else each_element_data[\"base_kv_LL\"]\n                        * np.sqrt(3)\n                        * self.dss_instance.Lines.NormAmps()\n                    )\n\n                    each_element_data[\"emergency_loading_kW\"] = (\n                        each_element_data[\"base_kv_LL\"]\n                        / np.sqrt(3)\n                        * self.dss_instance.Lines.EmergAmps()\n                        if each_element_data[\"num_phases\"] == 1\n                        else each_element_data[\"base_kv_LL\"]\n                        * np.sqrt(3)\n                        * self.dss_instance.Lines.EmergAmps()\n                    )\n\n                else:\n                    # everything other than lines but not capacitors i.e. transformers, reactors etc.\n                    # The impedance matrix for transformers and reactors are modeled as a shorted line here.\n                    # Need to work on this for future cases and replace with their zero sequence impedance may be\n\n                    each_element_data = {\n                        \"name\": self.dss_instance.CktElement.Name().split(\".\")[1],\n                        \"element\": element_type,\n                        # from opendss manual -&gt; length units = {none|mi|kft|km|m|ft|in|cm}\n                        \"length_unit\": 0,\n                        \"z_matrix_real\": self.__get_nonline_zmatrix(),\n                        \"z_matrix_imag\": self.__get_nonline_zmatrix(),\n                        \"length\": 0.001,\n                        \"from_bus\": self.dss_instance.CktElement.BusNames()[0].split(\n                            \".\"\n                        )[0],\n                        \"to_bus\": self.dss_instance.CktElement.BusNames()[1].split(\".\")[\n                            0\n                        ],\n                        # for non lines dss.Lines does not work so we need to work around with CktElement\n                        # CktElement is activated along with PDElements\n                        \"num_phases\": self.dss_instance.CktElement.NumPhases(),\n                        \"phases\": (\n                            {\"a\", \"b\", \"c\"}\n                            if self.dss_instance.CktElement.NumPhases() == 3\n                            else self.element_phase_identification(\n                                element_phases=self.dss_instance.CktElement.BusNames()[\n                                    0\n                                ].split(\".\")[1:]\n                            )\n                        ),\n                        \"is_switch\": False,\n                        \"is_open\": False,\n                    }\n\n                    # obtain the kVbase (line to line) of the element\n                    # we assume the voltage level of the element is the voltage of its secondary bus\n                    self.dss_instance.Circuit.SetActiveBus(\n                        self.dss_instance.CktElement.BusNames()[1].split(\".\")[0]\n                    )\n                    each_element_data[\"base_kv_LL\"] = round(\n                        self.dss_instance.Bus.kVBase() * np.sqrt(3), 2\n                    )\n\n                    # loading on the transformer is also on per phase basis\n                    if element_type == \"transformer\":\n                        each_element_data[\"normal_loading_kW\"] = (\n                            self.transformer_rating[each_element_data[\"name\"]]\n                            / each_element_data[\"num_phases\"]\n                        )\n\n                        # setting emergency loading to 150% of the normal loading\n                        each_element_data[\"emergency_loading_kW\"] = (\n                            1.5 * each_element_data[\"normal_loading_kW\"]\n                        )\n\n                    else:\n                        self.dss_instance.Transformers.First()\n                        rating_substation = self.dss_instance.Transformers.kVA()\n                        each_element_data[\"normal_loading_kW\"] = (\n                            rating_substation / each_element_data[\"num_phases\"]\n                        )\n\n                        # setting emergency loading to 150% of the normal loading\n                        each_element_data[\"emergency_loading_kW\"] = (\n                            1.5 * each_element_data[\"normal_loading_kW\"]\n                        )\n\n                pdelement_list.append(each_element_data)\n            element_activity_status = self.dss_instance.PDElements.Next()\n\n        return pdelement_list\n</code></pre>"},{"location":"ldrestoration/dssparser/#ldrestoration.dssparser.transformerhandler.TransformerHandler","title":"<code>ldrestoration.dssparser.transformerhandler.TransformerHandler</code>","text":"<p>TransformerHandler extracts the transformers (step down, step up, or split-phase service transformers) in the distribution model.</p> <p>Parameters:</p> Name Type Description Default <code>dss_instance</code> <code>ModuleType</code> <p>redirected opendssdirect instance </p> required To do <ul> <li>Address the extraction of delta connected primary in split-phase transformers</li> </ul> Source code in <code>ldrestoration/dssparser/transformerhandler.py</code> <pre><code>class TransformerHandler:\n    \"\"\"TransformerHandler extracts the transformers (step down, step up, or split-phase service transformers) in the distribution model.\n\n    Args:\n        dss_instance (ModuleType): redirected opendssdirect instance \n\n    To do:\n        * Address the extraction of delta connected primary in split-phase transformers\n    \"\"\"\n    def __init__(self, \n                 dss_instance: ModuleType) -&gt; None:\n        \"\"\"Initialize a TransformerHandler instance. This instance deals with transformers in the distribution model.\n\n        Args:\n            dss_instance (ModuleType): redirected opendssdirect instance \n        \"\"\"\n\n        self.dss_instance = dss_instance \n\n    def get_splitphase_primary(self) -&gt; dict[str,str]:    \n        \"\"\"Gets the primary phase information from split phase transformers to refer all loads to the primary\n\n        Returns:\n            splitphase_node_primary (dict[str,str]): A dictionary with secondary node as key and associated phase in primary as value\n            for eg. for ['A.3', 'B.1.0', 'B.0.2'] this will return {'B':['3']}\n        \"\"\"   \n        splitphase_node_primary = {}                \n        transformer_flag = self.dss_instance.Transformers.First()        \n        while transformer_flag:\n\n            if (self.dss_instance.CktElement.NumPhases() != 3) and self.dss_instance.Transformers.NumWindings() == 3:\n                # a split phase transformer is a three winding single phase transformer (two phase primary accounts for delta)\n\n                # name extracted of the secondary and phase extracted of the primary\n                bus_name = self.dss_instance.CktElement.BusNames()[1].split('.')[0]\n                bus_phases = self.dss_instance.CktElement.BusNames()[0].split('.')[1:]\n\n                if bus_name not in splitphase_node_primary:\n                    splitphase_node_primary[bus_name] = bus_phases\n\n            transformer_flag = self.dss_instance.Transformers.Next()\n\n        return splitphase_node_primary\n\n    def get_transformers(self) -&gt; list[dict[str,Union[int,str,float]]]: \n        \"\"\"Extract the bus data -&gt; name, basekV, latitude, longitude from the distribution model.\n\n        Returns:\n            bus_data (list[dict[str,Union[int,str,float]]]): list of bus data for each buses\n        \"\"\"\n        transformer_flag = self.dss_instance.Transformers.First()      \n        transformer_data = []  \n        while transformer_flag:\n            each_transformer = dict(name = self.dss_instance.Transformers.Name(),\n                                    numwindings = self.dss_instance.Transformers.NumWindings(),\n                                    connected_from = self.dss_instance.CktElement.BusNames()[0].split('.')[0],\n                                    connected_to = self.dss_instance.CktElement.BusNames()[1].split('.')[0])\n\n            transformer_data.append(each_transformer)\n            transformer_flag = self.dss_instance.Transformers.Next() \n        return transformer_data   \n</code></pre>"}]}